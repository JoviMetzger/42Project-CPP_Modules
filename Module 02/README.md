# Module 02

## üåÄ Exercise 00
### Description
This program introduces you to the Orthodox Canonical Form. <br>
**Orthodox Canonical Form:***
- *Default constructor*
- *Copy constructor*
- *Copy assignment operator*
- *Destructor*
<br>
### Installation
1. Compile the program:
```bash 
$ make 
```
2. Run the program with input:
```bash 
$ ./ex00
```
<br>
<br>

## üåÄ Exercise 01
### Description
In this exercise you will convert **float** to **int** and vice versa.
<br>
### Installation
1. Compile the program:
```bash 
$ make 
```
2. Run the program:
```bash 
$ ./ex01
```
<br>
<br>

## üåÄ Exercise 02
### Description
In this exercise you need to create your own operators.
- **The 6 comparison operators:** `>`, `<`, `>=`, `<=`, `==` and `!=`.
- **The 4 arithmetic operators:** `+`, `-`, `*`, and `/`.
- **The 4 increment/decrement:** 
&nbsp;&nbsp; `++i` *- pre-increment*,
&nbsp;&nbsp; `i++` *- post-increment*, 
&nbsp;&nbsp; `--i` *- pre-decrement*,
&nbsp;&nbsp; `i--` *- post-decrement*.
- **static member functions:** `static min()`, `static const min()`, `static max()` and `static const max()`.
<br>
### Installation
1. Compile the program:
```bash 
$ make 
```
2. Run the program:
```bash 
$ ./ex02
```
<br>
<br>

## üåÄ Exercise 03
### Description
In this exercise you need to implement a function which indicates whether a point is inside of a triangle or not.
<br>
### Installation
1. Compile the program:
```bash 
$ make 
```
2. Run the program:
```bash 
$ ./ex03
```


//----------------------------------------------------------------------------------------



# CPP_Modules üåä‚ûï‚ûï

Welcome to the C++ Modules! <br>
These modules are an introduction to **Object-Oriented Programming** in C++.
<br>
<br>

## 	üå† Useful Resources

These webpages provide a comprehensive resource for C++, containing all the essential information you need. <br>

- [w3schools](https://www.w3schools.com/cpp/cpp_getstarted.asp) 
- [cplusplus](https://cplusplus.com/doc/tutorial/) 
- [programiz](https://www.programiz.com/cpp-programming) 
- [geeksforgeeks](https://www.geeksforgeeks.org/c-plus-plus/)
<br>

## 	üå† C++ Modules

<details>
  <summary><strong>Module 00:</strong> <br> &nbsp;&nbsp;&nbsp;<em>(<strong>Topics:</strong> Namespace, class, member functions, and some basic stuff...)</em></summary>
<br>
  
## Module 01
Each of these exercises in the C++ module teaches you different aspects of C++ programming, including object-oriented programming, memory management, file handling, and more. 

### üî∏Exercise 00 - BraiiiiiiinnnzzzZ
This exercise covers the fundamentals of object-oriented programming in C++ and memory management. <br>
**You'll learn or practice:**
1. Creation of a simple class with private attributes and member functions.
2. Memory management, including object creation on the stack and heap.
3. Practice with C++ class constructors and destructors.

<br>

### üî∏Exercise 01 - Moar brainz!
This exercise focuses on creating pointers to objects and arrays.<br>
**You'll learn or practice:**
1. Allocation and management of memory for an array of objects.
2. Usage of pointers to objects and arrays.
3. Initialization and utilization of objects within an array.

<br>

### üî∏Exercise 02 - HI THIS IS BRAIN
This exercise explores pointers and references in C++ through string manipulation. <br>
**You'll learn or practice:**
1. Understand the concept of pointers and references in C++.
2. Practice printing memory addresses and values of variables, pointers, and references.

**NOTE:**
- (*PTR) can change the value and the address without influencing the original variable.
- (&REF) can change the original value.

<br>

### üî∏Exercise 03 - Unnecessary violence
In this exercise, you'll work with classes and objects, emphasizing constructors and object interactions. <br>
**You'll learn or practice:**
1. Learn about classes and objects in C++.
2. Practice using constructors to initialize objects.
3. Experience with object composition and interactions.

**NOTE:**
- For HumanA, Weapon (&REF) is required to/cannot be NULL; it always needs a weapon.
- For HumanB, Weapon (*PTR) can be NULL, allowing you to call attack() without setting the Weapon.
<br>

### üî∏Exercise 04 -  Sed is for losers
This exercise involves file handling and string manipulation, requiring you to recreate a missing source file <br>
**You'll learn or practice:**
1. Handling files in C++ without using C file manipulation functions.
2. String manipulation and replacement.
3. Error handling and input validation.

**NOTE:**
*Take care of:*
```bash
$ ./replace infile "" "hello"
$ ./replace infile "bee" "bee"
$ ./replace infile "bee" "been"
$ ./replace wrong_infle "hello" "Hello"
```
<br>

### üî∏Exercise 05 - Harl 2.0
In this exercise, you are tasked with recreating a missing source file based on provided header files and a log file. <br>
**You'll learn or practice:**
1. Usage of pointers to member functions in C++.
2. Implementation of a logging system with different log levels.

<br>

### üî∏Exercise 06 - Harl filter
This exercise focuses on program behavior control using the switch statement and log filtering. <br>
**You'll learn or practice:**
1. Application of the switch statement in C++.
2. Filtering and displaying messages based on log levels.
3. Gaining experience in controlling program behavior using conditional statements.

<br>

‚û°Ô∏è  [Installing/running the programs](https://github.com/JoviMetzger/42Project-CPP_Modules/tree/main/Module%2001)  ‚¨ÖÔ∏è
<br>
<br>

</details>

---

<details>
  <summary>Module 01</summary>
  <br>
  <br>
  <br>

</br>

</details>

---

<details>
  <summary>Module 02</summary>
  <br>
  <br>
  <br>

</br>

</details>

---

<details>
  <summary>Module 03</summary>
  <br>
  <br>
  <br>

</br>

</details>

---

<details>
  <summary>Module 04</summary>
  <br>
  <br>
  <br>

</br>

</details>

---

<details>
  <summary>Module 05</summary>
  <br>
  <br>
  <br>

</br>

</details>

---

<details>
  <summary>Module 06</summary>
  <br>
  <br>
  <br>

</br>

</details>

---

<details>
  <summary>Module 07</summary>
  <br>
  <br>
  <br>

</br>

</details>

---

<details>
  <summary>Module 08</summary>
  <br>
  <br>
  <br>

</br>

</details>

---

<details>
  <summary>Module 09</summary>
  <br>
  <br>
  <br>

</br>

</details>
<br>


--------------------------------------------------------------------------------------------------
 FLOARING POINT ##################
/*
    - floating-point represent real numbers (numbers with decimal points).
    - Mantissa: A floating-point number is composed of two main parts. The first part is called the "mantissa," which stores the significant digits of the number. It represents the actual value you want to work with.
    - Exponent: The second part is the "exponent," which indicates the scale or magnitude of the number. It shows where the decimal point should be placed in the mantissa.
    - Sign: Floating-point numbers can be positive or negative, so there's also a sign bit to represent the sign of the number.

--------------------------------------------------------------------------------

Floating-Point:
    - Precision: Floating-point numbers offer a variable level of precision. They use a fixed number of bits for the mantissa (significant digits) and another set of bits for the exponent. This allows them to represent a wide range of values but with varying precision. Smaller values have higher precision, and larger values have lower precision.
    - Range: Floating-point numbers can represent a wide range of values, both very small (close to zero) and very large, thanks to the exponent.
    - Flexibility: They are flexible for representing real numbers, but the precision might be overkill for some applications, and they can introduce rounding errors.
    - Storage: Floating-point numbers typically consume more memory due to their variable precision and need for an exponent.
    - Usage: Suitable for scientific calculations, simulations, and applications where a wide range of values and precision is required.

Fixed-Point:
    - Precision: Fixed-point numbers have a fixed number of decimal places. This means you specify a fixed precision for your numbers, and all numbers have the same precision.
    - Range: The range of fixed-point numbers is constrained to a predefined interval, determined by the number of bits allocated for the integer and fractional parts.
    - Accuracy: They are accurate within their specified precision, but they cannot represent values outside their fixed range or precision.
    - Storage: Fixed-point numbers are typically more memory-efficient compared to floating-point numbers because of their fixed precision.
    - Usage: Suitable for applications where you need a consistent level of precision and don't want to deal with the variability and potential rounding errors of floating-point numbers. Examples include embedded systems and applications with specific requirements for data representation.

In summary, the key difference between floating-point and fixed-point numbers in C++ is that floating-point provides variable precision and a wide range of values, while fixed-point offers a fixed precision and a limited range of values. The choice between them depends on the specific needs of your application and how you want to represent and work with numbers.

--------------------------------------------------------------------------------

A fixed point number has a specific number of bits (or digits) reserved for the integer part (the part to the left of the decimal point) and a specific number of bits reserved for the fractional part (the part to the right of the decimal point). No matter how large or small your number is, it will always use the same number of bits for each portion. For example, if your fixed point format was in decimal IIIII.FFFFF then the largest number you could represent would be 99999.99999 and the smallest non-zero number would be 00000.00001. Every bit of code that processes such numbers has to have built-in knowledge of where the decimal point is.

A floating point number does not reserve a specific number of bits for the integer part or the fractional part. Instead it reserves a certain number of bits for the number (called the mantissa or significand) and a certain number of bits to say where within that number the decimal place sits (called the exponent). So a floating point number that took up 10 digits with 2 digits reserved for the exponent might represent a largest value of 9.9999999e+50 and a smallest non-zero value of 0.0000001e-49.


--------------------------------------------------------------------------------

Correct, floating-point numbers include both float and double, while fixed-point numbers don't have predefined data types in the same way. float and double are standard floating-point data types in C++ and many other programming languages, designed to represent real numbers with variable precision.

Fixed-point representation, on the other hand, doesn't have dedicated data types like float and double. Instead, fixed-point numbers are typically implemented using integer data types (e.g., int, long) with a specific interpretation of the position of the decimal point. You decide the number of integer and fractional bits, effectively setting the precision and range for your fixed-point representation.

So, in a fixed-point representation, you have to manage the scaling and arithmetic manually, whereas in floating-point representation, the language and hardware take care of scaling and precision for you through the float and double data types. Fixed-point can be more work to implement but offers more control over precision and range, which can be advantageous in certain scenarios.

--------------------------------------------------------------------------------


    - IMAGES:
        - (https://www.google.com/imgres?imgurl=https%3A%2F%2Fwww.puntoflotante.net%2FIEEE-754-ENGLISH.jpg&tbnid=JLQHGm5FO6x3RM&vet=12ahUKEwi1j6Pir5GCAxVY6QIHHb2vDSAQxiAoAHoECAAQEg..i&imgrefurl=https%3A%2F%2Fwww.puntoflotante.net%2FFLOATING-POINT-FORMAT-IEEE-754.htm&docid=_aHMmmak4DS2qM&w=1586&h=632&itg=1&q=floating%20point%20in%20c%2B%2B&ved=2ahUKEwi1j6Pir5GCAxVY6QIHHb2vDSAQxiAoAHoECAAQEg);
        - (https://www.google.com/imgres?imgurl=https%3A%2F%2Fwww.c-programming-simple-steps.com%2Fimages%2FIEEE-754-float-representation.png&tbnid=atnns8NsA2RMYM&vet=12ahUKEwjoosSJsJGCAxVK2AIHHeBIBs8QxiAoAnoECAAQIg..i&imgrefurl=https%3A%2F%2Fwww.c-programming-simple-steps.com%2Fc-float.html&docid=GvXdJTvRdDSJNM&w=733&h=370&itg=1&q=floating%20point%20in%20c%2B%2B&ved=2ahUKEwjoosSJsJGCAxVK2AIHHeBIBs8QxiAoAnoECAAQIg);
        - (https://www.google.com/imgres?imgurl=https%3A%2F%2Fwww.researchgate.net%2Fpublication%2F348825339%2Ffigure%2Ffig1%2FAS%3A984782259380226%401611801795273%2FRepresentation-of-floating-point-and-fixed-point-numbers.ppm&tbnid=dK_UMv57jE7TqM&vet=12ahUKEwjO05q3r5GCAxVm_bsIHT8-AVIQxiAoA3oECAAQKg..i&imgrefurl=https%3A%2F%2Fwww.researchgate.net%2Ffigure%2FRepresentation-of-floating-point-and-fixed-point-numbers_fig1_348825339&docid=RAnocK8GnXGfDM&w=850&h=579&itg=1&q=floating%20point%20in%20c%2B%2B&ved=2ahUKEwjO05q3r5GCAxVm_bsIHT8-AVIQxiAoA3oECAAQKg);
        - (https://www.google.com/imgres?imgurl=https%3A%2F%2Fmedia.springernature.com%2Flw685%2Fspringer-static%2Fimage%2Fart%253A10.1007%252Fs00521-021-06821-x%2FMediaObjects%2F521_2021_6821_Fig1_HTML.png&tbnid=v5wNeGkYF1vNpM&vet=12ahUKEwi36o7lr5GCAxVH2aQKHeXJAsoQxiAoA3oECAAQFA..i&imgrefurl=https%3A%2F%2Flink.springer.com%2Farticle%2F10.1007%2Fs00521-021-06821-x&docid=GaBXsQs9VjESHM&w=685&h=329&itg=1&q=floating%20point%20in%20c%2B%2B&ved=2ahUKEwi36o7lr5GCAxVH2aQKHeXJAsoQxiAoA3oECAAQFA);
        - (https://www.google.com/imgres?imgurl=https%3A%2F%2Fwww.researchgate.net%2Fpublication%2F353927374%2Ffigure%2Ffig1%2FAS%3A1057456302080001%401629128637300%2FExample-of-fixed-point-number-representation.png&tbnid=lQ1SzGxqXAD2qM&vet=12ahUKEwi36o7lr5GCAxVH2aQKHeXJAsoQxiAoAXoECAAQGg..i&imgrefurl=https%3A%2F%2Fundefined.photos%2Fphoto-gallery%2Fhow-are-floating-point-numbers-represented-in-binary&docid=jhP3vuCfykFScM&w=850&h=492&itg=1&q=floating%20point%20in%20c%2B%2B&ved=2ahUKEwi36o7lr5GCAxVH2aQKHeXJAsoQxiAoAXoECAAQGg);
        - (https://www.google.com/imgres?imgurl=http%3A%2F%2Fwww.c-jump.com%2Fbcc%2Fcommon%2FTalk2%2FCxx%2FIEEE_754_fp_standard%2Fconst_images%2Fieee.gif&tbnid=zMhq6IzU2tfxIM&vet=12ahUKEwjLy4C0r5GCAxU95gIHHSFkDtsQMygWegUIARCBAQ..i&imgrefurl=http%3A%2F%2Fwww.c-jump.com%2Fbcc%2Fcommon%2FTalk2%2FCxx%2FIEEE_754_fp_standard%2FIEEE_754_fp_standard.html&docid=atOiniCr-wkS7M&w=511&h=233&q=floating%20point%20in%20c%2B%2B&ved=2ahUKEwjLy4C0r5GCAxU95gIHHSFkDtsQMygWegUIARCBAQ);
        - (https://www.google.com/imgres?imgurl=https%3A%2F%2Fslideplayer.com%2Fslide%2F14332519%2F89%2Fimages%2F25%2FC%252B%252B%2BData%2BTypes%2BSimple%2BStructured%2BAddress%2BIntegral%2BFloating.jpg&tbnid=o9HzBqqgaQaScM&vet=12ahUKEwj0jNet2pGCAxXvhP0HHT2bBNoQxiAoBXoECAAQFA..i&imgrefurl=https%3A%2F%2Fslideplayer.com%2Fslide%2F14332519%2F&docid=gaEQRDA1wEZglM&w=1024&h=768&itg=1&q=floating%20point%20in%20c%2B%2B&ved=2ahUKEwj0jNet2pGCAxXvhP0HHT2bBNoQxiAoBXoECAAQFA#imgrc=o9HzBqqgaQaScM&imgdii=YCal11WYyYFY6M);
        - (https://www.google.com/imgres?imgurl=https%3A%2F%2Ffastbitlab.com%2Fwp-content%2Fuploads%2F2022%2F07%2FFigure-5-5-1024x451.png&tbnid=QKv5dGrRk-5B4M&vet=12ahUKEwihvoPj2pGCAxV8mf0HHTtCAMEQxiAoAnoECAAQJA..i&imgrefurl=https%3A%2F%2Ffastbitlab.com%2Fsingle-vs-double-precision-floating-point-representation%2F&docid=HVA3EUNyYYAJsM&w=1024&h=451&itg=1&q=floating%20point%20in%20c%2B%2B&ved=2ahUKEwihvoPj2pGCAxV8mf0HHTtCAMEQxiAoAnoECAAQJA);
        - (https://www.google.com/imgres?imgurl=https%3A%2F%2Fi.stack.imgur.com%2F9kRBv.png&tbnid=a1QJoLwOeyCk2M&vet=12ahUKEwjg9vnr2pGCAxWw7bsIHYfvAqAQxiAoCnoECAAQIA..i&imgrefurl=https%3A%2F%2Fmath.stackexchange.com%2Fquestions%2F4514076%2Fscale-versus-precision&docid=TwlMUh0wr0iwIM&w=701&h=428&itg=1&q=floating%20point%20in%20c%2B%2B&ved=2ahUKEwjg9vnr2pGCAxWw7bsIHYfvAqAQxiAoCnoECAAQIA);
        - (https://www.google.com/imgres?imgurl=https%3A%2F%2Fdocs.actian.com%2Fopenroad%2F6.2%2FLangRef%2Fimages%2F02_LanguageElements.03.14.1.png&tbnid=5SFr2pWWH0kFJM&vet=12ahUKEwjfl63E25GCAxWt97sIHTDFCqcQxiAoCHoECAAQKg..i&imgrefurl=https%3A%2F%2Fdocs.actian.com%2Fopenroad%2F6.2%2FLangRef%2FNumeric_Data_Types.htm&docid=1uUsfIa2PdtA9M&w=215&h=125&itg=1&q=floating%20point%20in%20c%2B%2B&ved=2ahUKEwjfl63E25GCAxWt97sIHTDFCqcQxiAoCHoECAAQKg);
        - (https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRUBA-hST8J9KmXdEJZrPSI8PYaw10Yaw-T0PmATdY2MxrNJG3nT30XD7Ucw5LE20IdYg&usqp=CAU);
        - (https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSXpE_1AcR9emfZhjSwJHYIc356vJVi6qrcAlyLHuIsJhf-Pa5LPipHP5Xx9gUFb7nvaQ&usqp=CAU);
        - (https://www.google.com/imgres?imgurl=https%3A%2F%2Fapprize.best%2Fdata%2Foracle_2%2Foracle_2.files%2Fimage019.jpg&tbnid=KGun_iL4rhoCdM&vet=12ahUKEwjG062p25GCAxX6k_0HHbcLBJQQxiAoAnoECAAQIg..i&imgrefurl=https%3A%2F%2Fapprize.best%2Fdata%2Foracle_2%2F10.html&docid=bPEnmsxTOky8dM&w=1250&h=580&itg=1&q=floating%20point%20in%20c%2B%2B&ved=2ahUKEwjG062p25GCAxX6k_0HHbcLBJQQxiAoAnoECAAQIg);
        - (https://www.google.com/imgres?imgurl=https%3A%2F%2Fapprize.best%2Fdata%2Foracle_2%2Foracle_2.files%2Fimage019.jpg&tbnid=KGun_iL4rhoCdM&vet=12ahUKEwjG062p25GCAxX6k_0HHbcLBJQQxiAoAnoECAAQIg..i&imgrefurl=https%3A%2F%2Fapprize.best%2Fdata%2Foracle_2%2F10.html&docid=bPEnmsxTOky8dM&w=1250&h=580&itg=1&q=floating%20point%20in%20c%2B%2B&ved=2ahUKEwjG062p25GCAxX6k_0HHbcLBJQQxiAoAnoECAAQIg#imgrc=KGun_iL4rhoCdM&imgdii=sPhOOQANALz_cM);
        - ();

*/

--------------------------------------------------------------------------------------------------

Orthodox Canonical Form,###################################################################

Default Constructor:

A default constructor is a special member function of a class that is called when an object is created without any arguments.
It initializes the object's data members, in this case, the fixed-point number value, to a default value (usually 0 or a specified value).
It's called automatically when you create an object of the class without providing any explicit constructor arguments.
Copy Constructor:

A copy constructor is a member function that creates a new object by copying the values of another object of the same class.
It's used to initialize a new object with the same data as an existing object. For your fixed-point number class, this would copy the value from another fixed-point number.
Copy Assignment Operator Overload:

The copy assignment operator (often denoted as operator=) is a member function that allows you to assign the value of one object to another object of the same class.
It's used to make a deep copy of one object into another. It is typically invoked when you use the assignment operator, like obj1 = obj2, and ensures that obj1 now holds a copy of obj2's data.
Destructor:

A destructor is a special member function that is called when an object is destroyed or goes out of scope.
It is used to perform cleanup operations, such as releasing resources or deallocating memory, and is the opposite of a constructor.
In the context of your fixed-point number class, it might not have any specific cleanup operations, but in other classes, it is crucial for proper resource management.



const int fixed(): This declares a member function fixed that returns a const int, indicating that the integer returned by the function is constant and cannot be modified.

int fixed(const int x): This declares a member function fixed that takes a constant integer parameter x, meaning that x cannot be modified within the function.

int fixed() const: This declares a member function fixed that is marked as const, indicating that the function can be called on const objects of the class and ensures that the function does not modify the state of the object it is called on.

Now, to address your question:

int fixed(const): This is not a valid function declaration in C++. because the parameter name is missing. C++ requires you to specify both the type and name of a parameter. For example, you can declare int fixed(const int x), which specifies that the function takes a constant integer parameter named x.

int fixed() const and int fixed(const int x) are not the same. They serve different purposes:

int fixed() const: This marks the member function as const, allowing it to be called on const objects without modifying the object's state.

int fixed(const int x): This declares a function that takes a constant integer parameter, indicating that the parameter x cannot be modified within the function. This has nothing to do with whether the member function itself is const or not; it's about the parameter's constness.





satck & heap #########################################

/*
 * Allocate on the Heap:
 *  - The heapZombie is created on the heap using dynamic memory allocation, 
 *    typically through the new operator in C++. 
 *  - This means that the memory for the heapZombie object is allocated on the heap, 
 *    and you need to manually deallocate it when you're done with it using delete. 
 *  - Heap-allocated objects have a longer lifetime and exist 
 *    until explicitly freed by the programmer.
 *
 * Allocate on the Stack:
 *  - Stack-allocated objects are automatically managed by the program's execution stack. 
 *  - They have a shorter lifetime and are typically limited to the scope in which they are defined. 
 *  - When the scope ends (e.g., when the function returns), 
 *    the stack-allocated objects are automatically destroyed. 
 */




reference & pointer ##################################################################################

In C++, both references and pointers are used to indirectly access objects in memory, but they have some key differences:

Syntax:

Pointers are declared using the * symbol, such as int* ptr;, and they need to be dereferenced to access the value they point to, like *ptr = 42;.
References are declared using the & symbol as part of the variable type, like int& ref = someInt;, and you access the referenced value directly using the reference variable, like ref = 42;.
Initialization:

Pointers can be declared without initialization and can be assigned a value later, which may lead to uninitialized or dangling pointers.
References must be initialized when declared, and once initialized, they cannot be changed to refer to a different object. This enforces that references always refer to a valid object.
Nullability:

Pointers can be assigned a special value, nullptr, to indicate that they don't point to any valid object. This allows for the representation of the absence of a value.
References cannot represent null or be left uninitialized, so they always refer to a valid object.
Memory Management:

Pointers allow you to perform pointer arithmetic and can be used with dynamic memory allocation functions like new and delete. This gives you more control over memory management but also introduces the risk of memory leaks and other issues.
References do not support pointer arithmetic or dynamic memory allocation. They are generally safer in terms of memory management because they automatically manage the lifetime of the object they reference.
Syntax for Accessing Members:

With pointers, you use the arrow operator (->) to access members of an object pointed to by a pointer, like ptr->member.
With references, you can access members of the referenced object directly, like ref.member.
Function Arguments:

Pointers can be used to pass arguments by reference (using pointers to modify the original object) or by value (using pointers to pass a copy of the object).
References are typically used to pass arguments by reference, allowing functions to modify the original object efficiently.
Use Cases:

Pointers are more versatile and are commonly used in situations where you need dynamic memory allocation, optional values, or polymorphism (e.g., base class pointers to derived class objects).
References are typically used when you want to pass objects to functions by reference, indicating that the function should work with the original object and when you want to avoid null or uninitialized values.
In summary, references are safer and more concise for certain use cases, such as passing function arguments by reference. Pointers offer more flexibility and control over memory management but come with a higher risk of errors like null pointer dereferencing and memory leaks. The choice between them depends on your specific needs and the design of your C++ program.



copy & deep copy ################################################################################

A "deep copy" and a "shallow copy" are terms used to describe different ways of copying data, particularly in the context of object-oriented programming and data structures.

Deep Copy:

A deep copy creates a new object that is a duplicate of the original object, and it recursively copies all the objects referenced by the original object.
In the context of object-oriented programming, it means copying not just the values of the data members but also creating new instances of any objects or resources that the original object references.
Deep copy ensures that the copy is fully independent of the original object. Any changes made to the copied object or its internal data won't affect the original object.
Shallow Copy:

A shallow copy, on the other hand, creates a new object that is a copy of the original object, but it doesn't recursively copy the objects referenced by the original.
Instead, a shallow copy maintains references to the same objects as the original. In other words, it copies the references, not the underlying data.
Shallow copies are often faster and use less memory than deep copies because they don't replicate all the data and objects. However, they can lead to unintended side effects, as changes in the copied object can affect the original object and vice versa.
To illustrate the difference, consider a class that contains a pointer to dynamically allocated memory. When you perform a deep copy, you create a new object with its own dynamically allocated memory and copy the contents. In a shallow copy, you might just copy the pointer, which means both the original and the copy would point to the same dynamically allocated memory.

In summary, the key distinction is that a deep copy creates a completely independent duplicate, while a shallow copy shares some of the underlying data with the original object. The choice between deep and shallow copy depends on the specific requirements of your program and the data structures you're working with.





###################################################################################
Left-Shift (<<):

The left-shift operator (<<) moves the bits of an integer to the left by a specified number of positions. Each left shift effectively multiplies the integer by 2 raised to the power of the shift amount.
For example, if you have an integer x and you perform x << n, where n is the number of positions to shift, it's equivalent to multiplying x by 2^n.
In the context of your code, _fixedPoint = intValue << _fractionalBits; left-shifts the integer intValue by _fractionalBits positions, which scales the integer value to the fixed-point format. It's equivalent to multiplying intValue by 2^(_fractionalBits).
Right-Shift (>>):

The right-shift operator (>>) moves the bits of an integer to the right by a specified number of positions. Each right shift effectively divides the integer by 2 raised to the power of the shift amount.
For example, if you have an integer x and you perform x >> n, it's equivalent to dividing x by 2^n.
In the context of your code, return _fixedPoint >> _fractionalBits; right-shifts the _fixedPoint value by _fractionalBits positions to obtain the integer representation. This operation divides _fixedPoint by 2^(_fractionalBits), effectively removing the fractional part and returning the integer value.
Here's an example to illustrate left-shift and right-shift:

cpp
Copy code
int x = 5; // Binary: 00000101
int leftShifted = x << 2; // Binary: 00010100 (Decimal: 20)
int rightShifted = x >> 2; // Binary: 00000001 (Decimal: 1)
In this example, left-shifting x by 2 positions effectively multiplies it by 2^2 (which is 4), and right-shifting it by 2 positions divides it by 2^2, resulting in different values. These bitwise operations are handy for adjusting the scale and precision of numbers in fixed-point representations.

#################################################################################################
The first function, Fixed& Fixed::operator++(), is the pre-increment operator. It increments the value of the Fixed object (*this) and returns a reference to the updated object. It modifies the current object and then returns the updated object.

The second function, Fixed Fixed::operator++(int), is the post-increment operator. It also increments the value of the Fixed object (*this), but it returns a copy of the object as it was before the increment (stored in temp). After returning the original state, it increments the object. This operator is called post-increment because it returns the current value and then increments.

Here's how they can be used:

cpp
Copy code
Fixed a(5);

Fixed b = ++a; // Pre-increment: 'a' is incremented first, and then 'b' is assigned the updated value of 'a'.
Fixed c = a++; // Post-increment: 'c' is assigned the current value of 'a' (before increment), and then 'a' is incremented.
After these operations, the value of a will be incremented in both cases, but the timing of the increment and the value assigned to b and c will differ due to the pre-increment and post-increment behavior.

#####################################################################################################################
/*
We need to calculate the area of the main triangle and the three sub-triangles.
main triangle (ABC) 
sub-triangles always replaceing one point(A, B ,C) with P, so you get 3 triangles with (PBC), (APC), (ABP).

how do we calculate a area?
basic formula: (base * height) / 2.
but we don't know/have base neither height.
We only have 3 points (coordinates) of the triangle.
so we need to create the base and height.
so we are using this formula : Area = 1/2 * |x1(y2 - y3) + x2(y3 - y1) + x3(y1 - y2)|
to break it down we are doing this:
A = x1(y2 - y3)
B = x2(y3 - y1)
C = x3(y1 - y2)
areaABC = 0.5 * (A + B + C);

A represents the area of a smaller triangle formed using (x1, y1) as one vertex and the side between (x2, y2) and (x3, y3) as its base.
B represents the area of a smaller triangle formed using (x2, y2) as one vertex and the side between (x3, y3) and (x1, y1) as its base.
C represents the area of a smaller triangle formed using (x3, y3) as one vertex and the side between (x1, y1) and (x2, y2) as its base.

Note: 1/2 is the same as 0.5

Once we have all the areas of each triangle we compare if the area of the sub-triangles combined are the same as 
area of the main triangle.
if they are the point is inside the main triangle otherwise its not.
*/





# üå† Floating-Point & Fixed-Point
# üå† Orthodox Canonical Form
# üå† Stack & Heap allocation
# üå† Deep copy & Shallow copy
